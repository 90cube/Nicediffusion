# ImagePad 전면 재설계 가이드

## 1. 핵심 설계 원칙

### 1.1 모드 기반 아키텍처
```
ImagePad는 현재 모드에 따라 완전히 다른 UI/기능을 제공
- View Mode: 생성된 이미지 표시
- Upload Mode: 이미지 입력 대기
- Edit Mode: 이미지 편집
- Compare Mode: 원본/결과 비교
```

### 1.2 레이어 시스템
```
모든 이미지 작업을 레이어로 관리
- Background Layer: 체커보드/배경
- Image Layer: 실제 이미지
- Mask Layer: 마스크/선택 영역
- Overlay Layer: UI 요소/가이드
- Preview Layer: 임시 미리보기
```

## 2. 새로운 ImagePad 구조

### 2.1 기본 클래스 구조
```python
class ImagePad:
    def __init__(self, state_manager):
        self.state = state_manager
        self.current_mode = 'view'
        self.layers = {}
        self.canvas_manager = None
        self.mode_handlers = {
            'view': ViewModeHandler(),
            'txt2img': Txt2ImgHandler(),
            'img2img': Img2ImgHandler(),
            'inpaint': InpaintHandler(),
            'upscale': UpscaleHandler()
        }
```

### 2.2 모드 핸들러 패턴
```python
class ModeHandler(ABC):
    """각 모드의 기본 인터페이스"""
    
    @abstractmethod
    def setup(self, container):
        """UI 설정"""
        pass
    
    @abstractmethod
    def activate(self):
        """모드 활성화"""
        pass
    
    @abstractmethod
    def deactivate(self):
        """모드 비활성화"""
        pass
    
    @abstractmethod
    def get_generation_data(self):
        """생성용 데이터 추출"""
        pass
```

## 3. UI 레이아웃 설계

### 3.1 컨테이너 구조
```
[ImagePad Container]
├── [Header Toolbar] - 모드별 도구
├── [Main Canvas Area] - 중앙 작업 영역
│   ├── [Canvas Stack] - 레이어드 캔버스
│   └── [Upload Zone] - 드래그앤드롭 영역
├── [Side Panel] - 모드별 옵션
└── [Bottom Status] - 정보 표시
```

### 3.2 반응형 레이아웃
```python
# 기기/화면 크기에 따른 적응형 UI
- Desktop: 모든 기능 표시
- Tablet: 사이드 패널 접기
- Mobile: 필수 기능만, 제스처 중심
```

## 4. Canvas 통합 전략

### 4.1 통합 Canvas Manager
```javascript
class CanvasManager {
    constructor() {
        this.mode = 'view';
        this.layers = new Map();
        this.tools = new Map();
        this.history = [];
    }
    
    // 모드 전환
    switchMode(newMode) {
        this.cleanup();
        this.mode = newMode;
        this.loadModeModule(newMode);
    }
    
    // 이미지 입출력
    loadImage(source) {
        // File, URL, Base64, Blob 등 다양한 소스 지원
    }
    
    exportData() {
        return {
            image: this.getImageData(),
            mask: this.getMaskData(),
            metadata: this.getMetadata()
        };
    }
}
```

### 4.2 Python-JavaScript 브릿지
```python
# 양방향 통신 설정
class CanvasBridge:
    def __init__(self):
        self.handlers = {}
        
    def register_handler(self, event_type, handler):
        self.handlers[event_type] = handler
        
    def send_to_canvas(self, command, data):
        ui.run_javascript(f'window.canvasManager.{command}({json.dumps(data)})')
        
    def receive_from_canvas(self, event_type, data):
        if event_type in self.handlers:
            self.handlers[event_type](data)
```

## 5. 모드별 구현 가이드

### 5.1 Img2Img Mode
```
기능:
- 다양한 입력 방식 (드래그, 업로드, 붙여넣기, URL)
- 실시간 Denoising Strength 프리뷰
- 이미지 크기 조정 옵션
- 원본 보존/복원

UI 요소:
- 큰 드롭 영역
- 강도 슬라이더
- 크기 조정 도구
- 원본/편집 토글
```

### 5.2 Inpaint Mode
```
기능:
- 브러시 도구 (크기, 경도, 투명도)
- 선택 도구 (사각형, 원형, 자유형)
- 마스크 편집 (반전, 확장, 축소)
- 스마트 선택 (색상 기반, 에지 감지)

UI 요소:
- 도구 팔레트
- 브러시 설정 패널
- 마스크 레이어 토글
- 실행 취소/다시 실행
```

### 5.3 Compare Mode
```
기능:
- 스플릿 뷰 (좌우, 상하)
- 동기화된 줌/팬
- 차이점 하이라이트
- A/B 빠른 전환

UI 요소:
- 분할선 드래그
- 동기화 토글
- 비교 모드 선택
- 내보내기 옵션
```

## 6. 상태 관리 통합

### 6.1 통합 상태 구조
```python
image_pad_state = {
    'mode': 'view',
    'layers': {
        'image': None,
        'mask': None,
        'preview': None
    },
    'canvas_state': {
        'zoom': 1.0,
        'pan': {'x': 0, 'y': 0},
        'rotation': 0
    },
    'tool_state': {
        'current_tool': 'brush',
        'brush_size': 20,
        'brush_hardness': 0.8
    },
    'history': [],
    'undo_stack': []
}
```

### 6.2 이벤트 플로우
```
User Action → Canvas Event → JavaScript Handler 
    → Python Bridge → State Update → UI Update
    → Generation Pipeline → Result Display
```

## 7. 구현 로드맵

### Phase 1: 기본 구조 (1주)
```
1. 새로운 ImagePad 클래스 생성
2. 모드 시스템 구현
3. 기본 Canvas 통합
4. View/Upload 모드 구현
```

### Phase 2: 이미지 입력 (1주)
```
1. 다양한 입력 방식 구현
2. 이미지 전처리
3. 크기 조정 로직
4. StateManager 연동
```

### Phase 3: 편집 기능 (2주)
```
1. Canvas 도구 구현
2. 마스크 시스템
3. 히스토리/실행 취소
4. 편집 도구 UI
```

### Phase 4: 고급 기능 (1주)
```
1. 비교 모드
2. 배치 처리
3. 프리셋 시스템
4. 성능 최적화
```

## 8. 핵심 구현 포인트

### 8.1 파일 구조
```
image_pad/
├── __init__.py
├── image_pad.py          # 메인 클래스
├── mode_handlers/        # 모드별 핸들러
│   ├── base_handler.py
│   ├── view_handler.py
│   ├── img2img_handler.py
│   └── inpaint_handler.py
├── canvas/               # Canvas 관련
│   ├── canvas_manager.js
│   ├── tools.js
│   └── layers.js
└── utils/                # 유틸리티
    ├── image_utils.py
    └── bridge.py
```

### 8.2 확장성 고려사항
```
- 플러그인 시스템: 새로운 도구/모드 추가 용이
- 테마 지원: 다크/라이트 모드
- 단축키 시스템: 커스터마이징 가능
- 설정 저장: 사용자 프리셋
```

### 8.3 성능 최적화
```
- 큰 이미지: 타일 기반 렌더링
- 메모리 관리: 불필요한 레이어 정리
- 비동기 처리: 무거운 작업 분리
- 캐싱: 자주 사용되는 데이터
```

## 9. 마이그레이션 전략

### 9.1 기존 코드 재사용
```
- 이미지 저장 로직
- 히스토리 시스템
- 이벤트 시스템
- 생성 파이프라인 연동
```

### 9.2 점진적 교체
```
1. 새 ImagePad를 별도로 개발
2. 기능별로 테스트
3. 안정화 후 교체
4. 기존 코드 제거
```

이 가이드를 따라 ImagePad를 재구현하면:
- **유연성**: 새로운 모드 추가 용이
- **확장성**: 다양한 편집 기능 추가 가능
- **사용성**: 직관적인 UI/UX
- **통합성**: 기존 시스템과 매끄러운 연동
